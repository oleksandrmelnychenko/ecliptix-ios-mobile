import EcliptixCore
import Foundation

public struct DHValidator {

    private static let smallOrderPoints: [[UInt8]] = [

        [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ],

        [
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ],

        [
            0xE0, 0xEB, 0x7A, 0x7C, 0x3B, 0x41, 0xB8, 0xAE, 0x16, 0x56, 0xE3, 0xFA, 0xF1, 0x9F, 0xC4, 0x6A, 0xDA, 0x09,
            0x8D, 0xEB, 0x9C, 0x32, 0xB1, 0xFD, 0x86, 0x62, 0x05, 0x16, 0x5F, 0x49, 0xB8, 0x00
        ],

        [
            0x5F, 0x9C, 0x95, 0xBC, 0xA3, 0x50, 0x8C, 0x24, 0xB1, 0xD0, 0xB1, 0x55, 0x9C, 0x83, 0xEF, 0x5B, 0x04, 0x44,
            0x5C, 0xC4, 0x58, 0x1C, 0x8E, 0x86, 0xD8, 0x22, 0x4E, 0xDD, 0xD0, 0x9F, 0x11, 0x57
        ],

        [
            0xEC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],
        [
            0xED, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],

        [
            0xEE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F
        ],

        [
            0xCD, 0xEB, 0x7A, 0x7C, 0x3B, 0x41, 0xB8, 0xAE, 0x16, 0x56, 0xE3, 0xFA, 0xF1, 0x9F, 0xC4, 0x6A, 0xDA, 0x09,
            0x8D, 0xEB, 0x9C, 0x32, 0xB1, 0xFD, 0x86, 0x62, 0x05, 0x16, 0x5F, 0x49, 0xB8, 0x80
        ]
    ]

    public static func validateX25519PublicKey(_ publicKey: Data) -> Result<Void, SecurityError> {
        guard publicKey.count == CryptographicConstants.x25519PublicKeySize else {
            return .failure(.invalidInput(
                "Invalid public key size: expected \(CryptographicConstants.x25519PublicKeySize) bytes, got \(publicKey.count)"
            ))
        }

        if hasSmallOrder(publicKey) {
            return .failure(.invalidInput("Public key has small order (vulnerable to attacks)"))
        }

        if !isValidCurve25519Point(publicKey) {
            return .failure(.invalidInput("Public key is not a valid Curve25519 point"))
        }

        return .success(())
    }

    private static func isValidCurve25519Point(_ publicKey: Data) -> Bool {
        guard publicKey.count == CryptographicConstants.curve25519FieldElementSize else {
            return false
        }

        return isValidFieldElement(publicKey) && !hasSmallOrder(publicKey)
    }

    private static func isValidFieldElement(_ element: Data) -> Bool {
        guard element.count == CryptographicConstants.curve25519FieldElementSize else {
            return false
        }

        var words = [UInt32](repeating: 0, count: CryptographicConstants.field256WordCount)

        element.withUnsafeBytes { buffer in
            let bytes = buffer.bindMemory(to: UInt8.self)
            for i in 0..<CryptographicConstants.field256WordCount {
                let offset = i * CryptographicConstants.wordSize
                words[i] = UInt32(bytes[offset]) |
                          (UInt32(bytes[offset + 1]) << 8) |
                          (UInt32(bytes[offset + 2]) << 16) |
                          (UInt32(bytes[offset + 3]) << 24)
            }
        }

        words[7] &= CryptographicConstants.fieldElementMask

        return compareToFieldPrime(words) < 0
    }

    private static func compareToFieldPrime(_ element: [UInt32]) -> Int {

        let p: [UInt32] = [
            0x7FFFFFED, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF,
            0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF
        ]

        for i in stride(from: 7, through: 0, by: -1) {
            if element[i] < p[i] {
                return -1
            }
            if element[i] > p[i] {
                return 1
            }
        }

        return 0
    }

    private static func hasSmallOrder(_ point: Data) -> Bool {
        for smallOrderPoint in smallOrderPoints {
            if constantTimeEquals(point, Data(smallOrderPoint)) {
                return true
            }
        }
        return false
    }

    private static func constantTimeEquals(_ a: Data, _ b: Data) -> Bool {
        guard a.count == b.count else {
            return false
        }

        var result = 0
        for i in 0..<a.count {
            result |= Int(a[i] ^ b[i])
        }

        return result == 0
    }
}
