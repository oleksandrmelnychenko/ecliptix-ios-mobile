// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/secure_envelope.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ecliptix_Proto_Common_EnvelopeResultCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case success // = 0
  case badRequest // = 1
  case unauthorized // = 2
  case forbidden // = 3
  case notFound // = 4
  case methodNotAllowed // = 5
  case conflict // = 6
  case rateLimited // = 7
  case payloadTooLarge // = 8
  case internalError // = 10
  case serviceUnavailable // = 11
  case gatewayTimeout // = 12
  case insufficientStorage // = 13
  case cryptoError // = 20
  case invalidSignature // = 21
  case expiredKey // = 22
  case ratchetError // = 23
  case decryptionFailed // = 24
  case networkError // = 30
  case connectionLost // = 31
  case timeout // = 32
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .badRequest
    case 2: self = .unauthorized
    case 3: self = .forbidden
    case 4: self = .notFound
    case 5: self = .methodNotAllowed
    case 6: self = .conflict
    case 7: self = .rateLimited
    case 8: self = .payloadTooLarge
    case 10: self = .internalError
    case 11: self = .serviceUnavailable
    case 12: self = .gatewayTimeout
    case 13: self = .insufficientStorage
    case 20: self = .cryptoError
    case 21: self = .invalidSignature
    case 22: self = .expiredKey
    case 23: self = .ratchetError
    case 24: self = .decryptionFailed
    case 30: self = .networkError
    case 31: self = .connectionLost
    case 32: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .badRequest: return 1
    case .unauthorized: return 2
    case .forbidden: return 3
    case .notFound: return 4
    case .methodNotAllowed: return 5
    case .conflict: return 6
    case .rateLimited: return 7
    case .payloadTooLarge: return 8
    case .internalError: return 10
    case .serviceUnavailable: return 11
    case .gatewayTimeout: return 12
    case .insufficientStorage: return 13
    case .cryptoError: return 20
    case .invalidSignature: return 21
    case .expiredKey: return 22
    case .ratchetError: return 23
    case .decryptionFailed: return 24
    case .networkError: return 30
    case .connectionLost: return 31
    case .timeout: return 32
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ecliptix_Proto_Common_EnvelopeResultCode] = [
    .success,
    .badRequest,
    .unauthorized,
    .forbidden,
    .notFound,
    .methodNotAllowed,
    .conflict,
    .rateLimited,
    .payloadTooLarge,
    .internalError,
    .serviceUnavailable,
    .gatewayTimeout,
    .insufficientStorage,
    .cryptoError,
    .invalidSignature,
    .expiredKey,
    .ratchetError,
    .decryptionFailed,
    .networkError,
    .connectionLost,
    .timeout,
  ]

}

public enum Ecliptix_Proto_Common_EnvelopeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case request // = 0
  case response // = 1
  case notification // = 2
  case heartbeat // = 3
  case errorResponse // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .request
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .request
    case 1: self = .response
    case 2: self = .notification
    case 3: self = .heartbeat
    case 4: self = .errorResponse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .request: return 0
    case .response: return 1
    case .notification: return 2
    case .heartbeat: return 3
    case .errorResponse: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ecliptix_Proto_Common_EnvelopeType] = [
    .request,
    .response,
    .notification,
    .heartbeat,
    .errorResponse,
  ]

}

public struct Ecliptix_Proto_Common_SecureEnvelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encrypted EnvelopeMetadata (was plaintext)
  public var metaData: Data = Data()

  public var encryptedPayload: Data = Data()

  public var resultCode: Data = Data()

  public var authenticationTag: Data {
    get {return _authenticationTag ?? Data()}
    set {_authenticationTag = newValue}
  }
  /// Returns true if `authenticationTag` has been explicitly set.
  public var hasAuthenticationTag: Bool {return self._authenticationTag != nil}
  /// Clears the value of `authenticationTag`. Subsequent reads from it will return its default value.
  public mutating func clearAuthenticationTag() {self._authenticationTag = nil}

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var errorDetails: Data {
    get {return _errorDetails ?? Data()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  public var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  public mutating func clearErrorDetails() {self._errorDetails = nil}

  /// Nonce for header decryption (12 bytes)
  public var headerNonce: Data = Data()

  /// DH public key for ratchet (not encrypted, receiver needs this before decrypting metadata)
  public var dhPublicKey: Data {
    get {return _dhPublicKey ?? Data()}
    set {_dhPublicKey = newValue}
  }
  /// Returns true if `dhPublicKey` has been explicitly set.
  public var hasDhPublicKey: Bool {return self._dhPublicKey != nil}
  /// Clears the value of `dhPublicKey`. Subsequent reads from it will return its default value.
  public mutating func clearDhPublicKey() {self._dhPublicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authenticationTag: Data? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _errorDetails: Data? = nil
  fileprivate var _dhPublicKey: Data? = nil
}

public struct Ecliptix_Proto_Common_EnvelopeMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var envelopeID: String = String()

  public var channelKeyID: Data = Data()

  public var nonce: Data = Data()

  public var ratchetIndex: UInt32 = 0

  public var envelopeType: Ecliptix_Proto_Common_EnvelopeType = .request

  /// Note: dh_public_key moved to SecureEnvelope
  public var correlationID: String {
    get {return _correlationID ?? String()}
    set {_correlationID = newValue}
  }
  /// Returns true if `correlationID` has been explicitly set.
  public var hasCorrelationID: Bool {return self._correlationID != nil}
  /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelationID() {self._correlationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _correlationID: String? = nil
}

public struct Ecliptix_Proto_Common_EnvelopeError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Machine-readable error code
  public var errorCode: String = String()

  /// Human-readable message
  public var errorMessage: String = String()

  public var retryAfterSeconds: UInt32 {
    get {return _retryAfterSeconds ?? 0}
    set {_retryAfterSeconds = newValue}
  }
  /// Returns true if `retryAfterSeconds` has been explicitly set.
  public var hasRetryAfterSeconds: Bool {return self._retryAfterSeconds != nil}
  /// Clears the value of `retryAfterSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearRetryAfterSeconds() {self._retryAfterSeconds = nil}

  public var occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _occurredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_occurredAt = newValue}
  }
  /// Returns true if `occurredAt` has been explicitly set.
  public var hasOccurredAt: Bool {return self._occurredAt != nil}
  /// Clears the value of `occurredAt`. Subsequent reads from it will return its default value.
  public mutating func clearOccurredAt() {self._occurredAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _retryAfterSeconds: UInt32? = nil
  fileprivate var _occurredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ecliptix.proto.common"

extension Ecliptix_Proto_Common_EnvelopeResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "BAD_REQUEST"),
    2: .same(proto: "UNAUTHORIZED"),
    3: .same(proto: "FORBIDDEN"),
    4: .same(proto: "NOT_FOUND"),
    5: .same(proto: "METHOD_NOT_ALLOWED"),
    6: .same(proto: "CONFLICT"),
    7: .same(proto: "RATE_LIMITED"),
    8: .same(proto: "PAYLOAD_TOO_LARGE"),
    10: .same(proto: "INTERNAL_ERROR"),
    11: .same(proto: "SERVICE_UNAVAILABLE"),
    12: .same(proto: "GATEWAY_TIMEOUT"),
    13: .same(proto: "INSUFFICIENT_STORAGE"),
    20: .same(proto: "CRYPTO_ERROR"),
    21: .same(proto: "INVALID_SIGNATURE"),
    22: .same(proto: "EXPIRED_KEY"),
    23: .same(proto: "RATCHET_ERROR"),
    24: .same(proto: "DECRYPTION_FAILED"),
    30: .same(proto: "NETWORK_ERROR"),
    31: .same(proto: "CONNECTION_LOST"),
    32: .same(proto: "TIMEOUT"),
  ]
}

extension Ecliptix_Proto_Common_EnvelopeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST"),
    1: .same(proto: "RESPONSE"),
    2: .same(proto: "NOTIFICATION"),
    3: .same(proto: "HEARTBEAT"),
    4: .same(proto: "ERROR_RESPONSE"),
  ]
}

extension Ecliptix_Proto_Common_SecureEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SecureEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meta_data"),
    2: .standard(proto: "encrypted_payload"),
    3: .standard(proto: "result_code"),
    4: .standard(proto: "authentication_tag"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "error_details"),
    7: .standard(proto: "header_nonce"),
    8: .standard(proto: "dh_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.metaData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedPayload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.resultCode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._authenticationTag) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._errorDetails) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.headerNonce) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._dhPublicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.metaData.isEmpty {
      try visitor.visitSingularBytesField(value: self.metaData, fieldNumber: 1)
    }
    if !self.encryptedPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedPayload, fieldNumber: 2)
    }
    if !self.resultCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.resultCode, fieldNumber: 3)
    }
    try { if let v = self._authenticationTag {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._errorDetails {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if !self.headerNonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.headerNonce, fieldNumber: 7)
    }
    try { if let v = self._dhPublicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ecliptix_Proto_Common_SecureEnvelope, rhs: Ecliptix_Proto_Common_SecureEnvelope) -> Bool {
    if lhs.metaData != rhs.metaData {return false}
    if lhs.encryptedPayload != rhs.encryptedPayload {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs._authenticationTag != rhs._authenticationTag {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.headerNonce != rhs.headerNonce {return false}
    if lhs._dhPublicKey != rhs._dhPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ecliptix_Proto_Common_EnvelopeMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvelopeMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "envelope_id"),
    2: .standard(proto: "channel_key_id"),
    3: .same(proto: "nonce"),
    4: .standard(proto: "ratchet_index"),
    5: .standard(proto: "envelope_type"),
    6: .standard(proto: "correlation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.envelopeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.channelKeyID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.ratchetIndex) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.envelopeType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._correlationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.envelopeID.isEmpty {
      try visitor.visitSingularStringField(value: self.envelopeID, fieldNumber: 1)
    }
    if !self.channelKeyID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelKeyID, fieldNumber: 2)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 3)
    }
    if self.ratchetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.ratchetIndex, fieldNumber: 4)
    }
    if self.envelopeType != .request {
      try visitor.visitSingularEnumField(value: self.envelopeType, fieldNumber: 5)
    }
    try { if let v = self._correlationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ecliptix_Proto_Common_EnvelopeMetadata, rhs: Ecliptix_Proto_Common_EnvelopeMetadata) -> Bool {
    if lhs.envelopeID != rhs.envelopeID {return false}
    if lhs.channelKeyID != rhs.channelKeyID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.ratchetIndex != rhs.ratchetIndex {return false}
    if lhs.envelopeType != rhs.envelopeType {return false}
    if lhs._correlationID != rhs._correlationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ecliptix_Proto_Common_EnvelopeError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvelopeError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .standard(proto: "error_message"),
    3: .standard(proto: "retry_after_seconds"),
    4: .standard(proto: "occurred_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._retryAfterSeconds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._occurredAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.errorCode.isEmpty {
      try visitor.visitSingularStringField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try { if let v = self._retryAfterSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._occurredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ecliptix_Proto_Common_EnvelopeError, rhs: Ecliptix_Proto_Common_EnvelopeError) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs._retryAfterSeconds != rhs._retryAfterSeconds {return false}
    if lhs._occurredAt != rhs._occurredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
